var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DecompUtil","category":"page"},{"location":"#DecompUtil","page":"Home","title":"DecompUtil","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DecompUtil.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a julia wrapper to DecompUtil, created by Devansh Agrawal. I have added a few small functionalities, but have not exported all of the functions provided by the original authors. If there are some particular functions you would like to be able to use, let me know and I should be able to wrap them without much difficulty. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is research code, and so there is no guarantee of correctness, but so far it has worked well for me. If you find an error, please let me know by raising a Github Issue. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"All credits should go to the original authors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{liu2017planning,\n  title={Planning dynamically feasible trajectories for quadrotors using safe flight corridors in 3-d complex environments},\n  author={Liu, Sikang and Watterson, Michael and Mohta, Kartik and Sun, Ke and Bhattacharya, Subhrajit and Taylor, Camillo J and Kumar, Vijay},\n  journal={IEEE Robotics and Automation Letters},\n  volume={2},\n  number={3},\n  pages={1688--1695},\n  year={2017},\n  publisher={IEEE}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"For those interested, the wrapper works by exposing a C interface to the original library, creating a JLL package using BinaryBuilder, and then creating the Julia package.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main export of this library is seedDecomp. This performs a decomposition in a 2D or 3D space, and returns a set of hyperplanes that indicate the safe flight corridor. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"2D example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DecompUtil\n\n# seed from which the decomposition starts\npos = [0,0.] \n\n# define all the obstacle points\nobs = [[-0.2, 1.5], [1, 0.], [0.8,-1.], [ -0.5, -0.5]]\n\n# defines the bounding box (i.e., -2:2 on x axis, -2:2 on y axis)\nbbox = [2,2.]\n\n# I am honestly not too sure what this does,\n# and it doesnt seem to have an impact on the result.\n# (but it needs to be greater than 0)\ndilation_radius = 0.1\n\nresult = seedDecomp(pos, obs, bbox, dilation_radius)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This returns a vector of Hyperplanes. Each hyperplane v has a point v.p and a normal v.n and defines the free area as the halfspace: ","category":"page"},{"location":"","page":"Home","title":"Home","text":" x  n^T x leq n^T p ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can convert it to a constraints matrix of the form Ax leq b:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A, b = constraints_matrix(result)\n\nA","category":"page"},{"location":"","page":"Home","title":"Home","text":"b","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we can verify that the seed lies inside this polyhedron:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A * pos - b","category":"page"},{"location":"","page":"Home","title":"Home","text":"A * pos <= b","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since we provide a bounding box, the result is always a bounded polyhedron. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can visualize it as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\n\nfunction plot_2D!(pos, obs, bbox, res)\n    \n    scatter!([pos[1]], [pos[2]], label=\"Seed\")\n    scatter!(first.(obs), last.(obs), label=\"Obstacles\")\n    vline!([pos[1] - bbox[1], pos[1] + bbox[1]], label=\"Bounding Box\", linestyle=:dash, linewidth=2, color=:black)\n    hline!([pos[2] - bbox[2], pos[2] + bbox[2]], label=false, linestyle=:dash, linewidth=2, color=:black)\n\n    for (i, v) in enumerate(res)\n        p = v.p\n        n = v.n\n        lab = i==1 ? \"Hyperplane\" : false\n        plot!(t -> p[1] + n[2]*t, t-> p[2] - n[1]*t, -4,4, label=lab, color=:blue)\n    end\n\n    # plot!(legend = :outerleft)\n\n    \nend\n\n\nplot()\nplot_2D!(pos, obs, bbox, result)\nxlims!(-2.5, 2.5)\nylims!(-2.5, 2.5)\nplot!(aspect_ratio=:equal)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, for convenience, a shrink function is provided, that shrinks the polyhedron by a distance d","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nshrunk_result = DecompUtil.shrink(result, 0.3)\n\nplot()\nplot_2D!(pos, obs, bbox, shrunk_result)\nxlims!(-2.5, 2.5)\nylims!(-2.5, 2.5)\nplot!(aspect_ratio=:equal)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note, there is no guarantee that the shrunk polyhedron contains the seed, or indeed is non-empty. Also, note the polyhedron can have redundant constraints.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note, no plotting utilities are not exported, so as to not introduce dependencies on plotting. ","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DecompUtil]","category":"page"},{"location":"#DecompUtil.Hyperplane","page":"Home","title":"DecompUtil.Hyperplane","text":"Hyperplane{N, F}(p, n)\n\nrepresents a hyperplane passing through the point p with normal vector n. N is the dimension, F is the type of the vector. Uses StaticVectors to represent p and n internally.\n\nExample:     Hyperplane([1.0, 0.0], [1.0, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"#DecompUtil.constraints_matrix-Union{Tuple{V}, Tuple{F}, Tuple{N}} where {N, F, V<:AbstractArray{DecompUtil.Hyperplane{N, F}, 1}}","page":"Home","title":"DecompUtil.constraints_matrix","text":"constraints_matrix(vs::Vector{Hyperplane})\n\nconstructs a linear constraints matrix from a list of hyperplanes\n\n\n\n\n\n","category":"method"},{"location":"#DecompUtil.seedDecomp","page":"Home","title":"DecompUtil.seedDecomp","text":"seedDecomp(pos, obs, bbox, dilation_radius, max_poly=1)\n\nPerform a seed decomposition in a 2D or 3D space.\n\nInputs:\n\npos is the starting point of the seed\nobs is a vector of points representing obstacles in the environment. In the format [[x1, y1], [x2, y2], ....]. You can pass in a vector of static arrays if you want. \nbbox is the size of the bounding box within which the decomposition should happen\ndilation_radius is the dilation radius (refer to original paper)\nmax_poly is the assumed maximum number of hyperplanes in the resulting solution. If this is smaller than the true number, the library is called again with a larger max_poly.\n\nReturns:\n\nPolyhedron representing the free space.\n\n\n\n\n\n","category":"function"},{"location":"#DecompUtil.seedDecomp_2D","page":"Home","title":"DecompUtil.seedDecomp_2D","text":"seedDecomp_2D(pos, obs, bbox, dilation_radius, max_poly=1)\n\nPerform a seed decomposition in a 2D space.\n\nInputs:\n\npos is the starting point of the seed\nobs is a vector of points representing obstacles in the environment. In the format [[x1, y1], [x2, y2], ....]\nbbox is the size of the bounding box within which the decomposition should happen\ndilation_radius is the dilation radius (refer to original paper)\nmax_poly is the assumed maximum number of hyperplanes in the resulting solution. If this is smaller than the true number, the library is called again with a larger max_poly.\n\nReturns:\n\nPolyhedron representing the free space.\n\n\n\n\n\n","category":"function"},{"location":"#DecompUtil.seedDecomp_3D","page":"Home","title":"DecompUtil.seedDecomp_3D","text":"seedDecomp_3D(pos, obs, bbox, dilation_radius, max_poly=1)\n\nPerform a seed decomposition in a 3D space.\n\nInputs:\n\npos is the starting point of the seed, e.g. [x0, y0, z0]\nobs is a vector of points representing obstacles in the environment. In the format [[x1, y1, z1], [x2, y2, z2], ....]\nbbox is the size of the bounding box within which the decomposition should happen\ndilation_radius is the dilation radius (refer to original paper)\nmax_poly is the assumed maximum number of hyperplanes in the resulting solution. If this is smaller than the true number, the function is called again with a larger max_poly.\n\nReturns:\n\nVector{Hyperplane} representing the free space.\n\n\n\n\n\n","category":"function"},{"location":"#DecompUtil.seedDecomp_3D_fast-Union{Tuple{VF}, Tuple{Any, VF, VF, VF, Any, Any}, Tuple{Any, VF, VF, VF, Any, Any, Any}} where VF<:AbstractVector{Float32}","page":"Home","title":"DecompUtil.seedDecomp_3D_fast","text":"seedDecomp_3D_fast(pos, obs_x, obs_y, obs_z, bbox, dilation_radius, max_poly=100)\n\nPerform a seed decomposition in a 3D space, but a slightly more optimized version.\n\nInputs:\n\npos is the starting point of the seed, e.g. [x0, y0, z0]\nobs_x, obs_y, obs_z are each  vectors representing obstacles in the environment.\nbbox is the size of the bounding box within which the decomposition should happen\ndilation_radius is the dilation radius (refer to original paper)\nmax_poly is the assumed maximum number of hyperplanes in the resulting solution. If this is smaller than the true number, the function is called again with a larger max_poly.\n\nReturns:\n\nVector{Hyperplane} representing the free space.\n\n\n\n\n\n","category":"method"},{"location":"#DecompUtil.shrink-Union{Tuple{V}, Tuple{F}, Tuple{N}, Tuple{V, Any}} where {N, F, V<:AbstractArray{DecompUtil.Hyperplane{N, F}, 1}}","page":"Home","title":"DecompUtil.shrink","text":"shrink(vs::Vector{Hyperplane}, d)\n\nreturns a new list of hyperplanes, where the free space has been decreased by a margin d.  You can pass in negative values for d if you want to expand the region.  There is no guarantee that the resulting polyhedron is non-empty, or that it doesnt include redundant constraints. \n\n\n\n\n\n","category":"method"}]
}
